╔══════════════════════════════════════════════════════════════╗
║                                                              ║
║     🎉🎉🎉  MySQL → Cloud SQL 同步系统部署完成  🎉🎉🎉      ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝

═══════════════════════════════════════════════════════════════
项目信息
═══════════════════════════════════════════════════════════════
报告生成时间: 2026-01
系统版本: v1.0
部署状态: ✅ 成功运行

═══════════════════════════════════════════════════════════════
系统架构
═══════════════════════════════════════════════════════════════

  生产MySQL (35.220.164.252:3399)
       ↓ Binlog实时复制 (< 1秒)
  中间服务器 (38.246.255.177)
       ↓ 智能增量同步 (3分钟)
  Cloud SQL (35.220.220.225)

✅ MySQL 端口与用途对照表
| 环境 | 主机 / IP | MySQL 端口 | 主要用途 | 使用账号 | 说明 |
|---|---|---|---|---|---|
| **生产服务器（PROD）** | `35.220.164.252` | **3306** | 业务主库 | `monitor_user` | 生产数据源，只读/受限访问，用于同步到中间服务器 |
| **中间服务器（MIDDLE）** | `localhost` | **3306** | 同步中转库 | `root` | 核心操作库：校验、比对、基线、同步源 |
| **Cloud SQL（CLOUD）** | `35.220.220.225` | **3306** | 云端目标库 | `root` | 最终云端数据库，同步写入目标 |


═══════════════════════════════════════════════════════════════
部署清单
═══════════════════════════════════════════════════════════════
✅ MySQL主从复制 (ROW格式)
✅ 数据保护系统 (智能白名单模式)
✅ 智能增量同步 (checksum对比)
✅ 邮件告警系统 (QQ邮箱)
✅ 自动化任务 (Crontab)
✅ 管理工具集 (manage.sh)

═══════════════════════════════════════════════════════════════
当前状态
═══════════════════════════════════════════════════════════════

定时任务:

# 每3分钟执行一次安全同步（先检查，后同步）
*/3 * * * * bash /opt/mysql-sync/scripts/safe_sync.sh >> /opt/mysql-sync/logs/sync.log 2>&1

# 每5分钟执行数据保护检查
*/5 * * * * cd /opt/mysql-sync/scripts && python3 data_protection.py >> /opt/mysql-sync/logs/protection.log 2>&1

# 每小时清理7天前的日志
0 * * * * find /opt/mysql-sync/logs -name "*.log" -mtime +7 -delete

# UTC+8每天凌晨3点创建新的数据基线
0 19 * * * cd /opt/mysql-sync/scripts && python3 data_protection.py init >> /opt/mysql-sync/logs/baseline.log 2>&1

定时任务:
  • 每3分钟: 智能同步
  • 每5分钟: 数据保护检查
  • 每天3点: 创建新基线

邮件告警:
  • 发件/收件邮箱: 1657703775@qq.com
  • 测试状态: ✅ 成功

═══════════════════════════════════════════════════════════════
性能指标
═══════════════════════════════════════════════════════════════
主从复制延迟: < 1秒    ⭐⭐⭐⭐⭐
同步延迟: < 3分钟      ⭐⭐⭐⭐⭐
数据一致性: 99.94%     ⭐⭐⭐⭐⭐
系统可用性: 24/7       ⭐⭐⭐⭐⭐

═══════════════════════════════════════════════════════════════
数据保护机制
═══════════════════════════════════════════════════════════════
✅ 大规模删除检测 (阈值: 10%)
✅ 关键表结构锁定
✅ 业务表结构智能检查 (白名单: quota_data, tokens, users)
✅ 自动暂停保护
✅ 邮件实时告警

═══════════════════════════════════════════════════════════════
告警通知
═══════════════════════════════════════════════════════════════
发件邮箱: 1657703775@qq.com
收件邮箱: 1657703775@qq.com

告警级别：INFO / WARNING / CRITICAL

告警场景:
  • 检测到大规模数据删除
  • 检测到关键表结构变更
  • 主从复制异常
  • 同步连接失败

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
系统文件
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
核心文件:
  ✅ .env (594)
  ✅ smart_sync.py (6.3K)
  ✅ data_protection.py (8.8K)
  ✅ manage.sh (4.5K)
  ✅ alert_email.py (7.0K)

日志文件:
  ✅ sync.log
  ✅ protection.log
  ✅ baseline.log

═══════════════════════════════════════════════════════════════
重要文件路径
═══════════════════════════════════════════════════════════════
配置文件: /opt/mysql-sync/.env
脚本: /opt/mysql-sync/scripts/
日志: /opt/mysql-sync/logs/
缓存: /opt/mysql-sync/cache/

═══════════════════════════════════════════════════════════════
日常使用
═══════════════════════════════════════════════════════════════
SSH登录: 
  ssh root@38.246.255.177

查看系统状态:
  bash /opt/mysql-sync/scripts/manage.sh status

手动同步:
  bash /opt/mysql-sync/scripts/manage.sh sync（手动执行一次同步，补齐数据）

<每周维护>
验证数据:
  bash /opt/mysql-sync/scripts/manage.sh verify
检查磁盘:
  df -h /opt/mysql-sync

<每日检查>
查看日志（sync/protection/baseline）:
  tail -f /opt/mysql-sync/logs/sync.log
  tail -50 /opt/mysql-sync/logs/protection.log 
  tail -f /opt/mysql-sync/logs/baseline.log

暂停/恢复:
  bash /opt/mysql-sync/scripts/manage.sh pause
  bash /opt/mysql-sync/scripts/manage.sh resume（解决完问题并恢复）

更新基线并恢复 
  bash /opt/mysql-sync/scripts/confirm_and_resume.sh
或者分步执行：
# 1. 接受新结构（更新基线）
  bash /opt/mysql-sync/scripts/manage.sh baseline
# 2. 恢复同步
  bash /opt/mysql-sync/scripts/manage.sh resume



## `manage.sh` 命令解释

-   **`manage.sh resume`**:
    -   **含义**：“我已经在源头解决了问题，现在请继续工作。”
    -   **操作**：只删除暂停标记。
    -   **适用场景**：你手动修复了源头的错误（如恢复了表结构或数据）之后使用。

-   **`manage.sh baseline`**：
    -   **含义**：“现在服务器上的状态是新的、正确的标准，请记住它。”
    -   **操作**：用当前的表结构和行数，覆盖旧的基线。
    -   **适用场景**：在确认业务升级是正常的情况下使用，通常配合`resume`一起用。

-   **`confirm_and_resume.sh`**：
    -   这是一个方便的组合脚本，它等于 `manage.sh baseline` + `manage.sh resume` + 一些验证。
  
-   **`manage.sh sync`**: 
    -   主要用于**手动触发一次增量数据同步**，它的核心价值在于**即时性**和**可控性**，让你可以在需要的时候立即同步数据，而不是被动地等待定时任务。


灾难发生后，如何从google cloud恢复数据到生产服务器

    
═══════════════════════════════════════════════════════════════
维护建议
═══════════════════════════════════════════════════════════════
每日:
  • 检查邮件是否有告警
  • 查看同步日志

每周:
  • 验证数据一致性
  • 检查磁盘空间

每月:
  • 性能评估
  • 日志归档

═══════════════════════════════════════════════════════════════
故障处理
═══════════════════════════════════════════════════════════════
问题1: 收到告警邮件
  1. SSH登录: ssh root@38.246.255.177
  2. 查看原因: cat /opt/mysql-sync/PAUSE_SYNC
  3. 确认无误后恢复: manage.sh resume

问题2: 数据差异大
  1. 检查复制状态: manage.sh status
  2. 手动同步: manage.sh sync
  3. 验证数据: manage.sh verify




╔═══════════════════════════════════════════════════╗
║                                                   ║
║     🎉🎉🎉  灾难发生后重建生产数据库  🎉🎉🎉     ║
║                                                   ║
╚═══════════════════════════════════════════════════╝

灾难发生后，从 Google Cloud SQL 恢复数据到新的生产服务器的具体方案。

单向同步架构：`生产服务器(PROD_HOST)` → `中间服务器(MIDDLE_HOST)` → `Cloud SQL(CLOUD_HOST)`。其中，Cloud SQL 作为最终的备份目的地。

因此，当生产服务器发生灾难时，**Cloud SQL (`bf-bynewapi` 数据库) ** 是我们恢复数据的黄金数据源。恢复过程本质上是现有同步脚本 `smart_sync.py`  的逆向操作。

---

=====================================================
##### **灾难恢复方案：从 Cloud SQL 恢复至新生产服务器**
=====================================================

=======================================================================
#### **第一步：准备新的生产服务器环境**
=======================================================================

1.  **准备服务器**：确保您有一台新的、干净的服务器作为新的生产服务器。
2.  **安装MySQL**：在新服务器上安装与原生产环境相同版本的 MySQL Server。
3.  **网络配置**：
    *   确保新生产服务器可以访问 Google Cloud SQL 的 IP 地址 `35.220.220.225` 的 `3306` 端口 [1]。
    *   在 Google Cloud 的防火墙规则中，可能需要将新生产服务器的 IP 地址加入到 Cloud SQL 实例的授权网络列表中。
4.  **创建数据库**：在新生产服务器的 MySQL 中，创建一个空的数据库，名称与原生产数据库相同，即 `bynewapi` [1]。

    ```sql
    CREATE DATABASE bynewapi CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
    ```
=========================================================================
###准备工作（084f23f3ce683ec1是就服务器root用户的密码，以下换成新服务器root的密码）
=========================================================================

##在MySQL生产服务器 (旧服务器IP：35.220.164.252，以下换成新服务器IP)

# SSH登录
ssh root@35.220.164.252

# 1. 检查Binlog配置
mysql -uroot -p'084f23f3ce683ec1' -e "SHOW VARIABLES LIKE 'log_bin%';"
mysql -uroot -p'084f23f3ce683ec1' -e "SHOW VARIABLES LIKE 'binlog_format';"
mysql -uroot -p'084f23f3ce683ec1' -e "SHOW VARIABLES LIKE 'server_id';"

# 2. 如果需要修改配置
sudo vim /etc/my.cnf
添加以下配置（如果不存在）：
[mysqld]
server-id = 1
log_bin = mysql-bin
binlog_format = ROW
binlog_row_image = FULL
expire_logs_days = 7
max_binlog_size = 500M


# 3. 重启MySQL（如果修改了配置）
sudo systemctl restart mysqld

# 4. 创建复制用户
mysql -uroot -p'084f23f3ce683ec1' << 'EOF'
CREATE USER 'repl_user'@'%' IDENTIFIED BY 'Repl@Pass#2024Secure';
GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'repl_user'@'%';

CREATE USER 'monitor_user'@'%' IDENTIFIED BY 'Monitor@Pass#2024';
GRANT SELECT, PROCESS, REPLICATION CLIENT ON *.* TO 'monitor_user'@'%';

FLUSH PRIVILEGES;
EOF

# 5. 记录当前Binlog位置
mysql -uroot -p'084f23f3ce683ec1' -e "SHOW MASTER STATUS\G" > /tmp/master_status.txt
cat /tmp/master_status.txt

# 6. 导出数据库初始备份
mysqldump -uroot -p'084f23f3ce683ec1' \
  --single-transaction \
  --master-data=2 \
  --routines \
  --triggers \
  --events \
  --databases bynewapi > /tmp/bynewapi_initial.sql

# 7. 计算校验和（用于验证）
md5sum /tmp/bynewapi_initial.sql > /tmp/bynewapi_initial.sql.md5

# 8. 配置防火墙（允许中间服务器连接）
sudo firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="38.246.255.177" port protocol="tcp" port="3306" accept'
sudo firewall-cmd --reload


=======================================
#### **第二步：执行数据恢复（核心操作）**
=======================================

这是恢复过程最关键的一步。我们将使用 `mysqldump` 工具将 Cloud SQL 上的整个数据库备份下来，然后直接导入到新的生产服务器中。

登录到**新的生产服务器**上，执行以下命令。这条命令会通过管道(pipe)实现无缝的数据导出和导入，无需在本地保存临时的SQL文件。

**恢复命令：**

```bash
# 请将 [NEW_PROD_USER] 和 [NEW_PROD_PASS] 替换为新生产服务器MySQL的用户名和密码（下面的步骤中有新建的用户名和密码和之前的一样没变 用户名:monitor_user 密码:Monitor@Pass#2024）
mysqldump -h 35.220.220.225 -u root -p'cGd4mQmiAyps6zsmQy@' --single-transaction --quick --lock-tables=false bf-bynewapi | mysql -h localhost -u [NEW_PROD_USER] -p'[NEW_PROD_PASS]' bynewapi
替换后（可以直接复制执行）：
mysqldump -h 35.220.220.225 -u root -p'cGd4mQmiAyps6zsmQy@' --single-transaction --quick --lock-tables=false bf-bynewapi | mysql -h localhost -u monitor_user -p'Monitor@Pass#2024' bynewapi

**命令详解：**
*   `mysqldump -h 35.220.220.225 -u root -p'cGd4mQmiAyps6zsmQy@' ... bf-bynewapi`: 这部分连接到您的 Cloud SQL 实例，并将 `bf-bynewapi` 数据库的内容导出为 SQL 语句。
*   `|`: 这是一个管道符，它将左边命令的输出（即导出的SQL语句）直接作为右边命令的输入。
*   `mysql -h localhost -u [NEW_PROD_USER] ... bynewapi`: 这部分连接到新生产服务器本地的 MySQL，并将接收到的 SQL 语句执行到 `bynewapi` 数据库中，从而完成数据导入。

**注意**：数据量较大时，此过程可能需要一些时间。请耐心等待命令执行完成。


==============================
#### **第三步：验证恢复的数据**
==============================

数据恢复完成后，必须进行验证，确保数据完整且正确。

1.  登录到新生产服务器的 MySQL。
2.  执行一些查询来验证数据，这可以参考 `manage.sh` 脚本中的验证逻辑 [6]。

    ```bash
    # 登录MySQL
    mysql -u monitor_user -p
    
    # 进入数据库
    USE bynewapi;
    
    # 抽查几个关键表的数据量
    SELECT COUNT(*) FROM quota_data;
    SELECT COUNT(*) FROM tokens;
    SELECT COUNT(*) FROM users;
    SELECT COUNT(*) FROM redemptions;
    
    # 抽查一条最近的数据
    SELECT * FROM top_ups ORDER BY id DESC LIMIT 1;
    ```

3.  将查询结果与您对业务数据的预期进行比较。如果数据看起来正常，则恢复成功。


=====================================
#### **第四步：后续操作和重新建立同步**
=====================================

1.  **更新应用配置**：将您的应用程序的数据库连接配置指向新的生产服务器地址。
2.  **重启应用服务**：重启您的应用程序，使其连接到新的数据库并恢复对外服务。
3.  **重新配置同步链路**：
    *   灾难恢复后，您需要重新建立从新生产服务器到 Cloud SQL 的数据同步链路。
    *   登录到您的**中间服务器** (`38.246.255.177`) [2]。
    *   编辑 `.env` 配置文件 `/opt/mysql-sync/.env` [1]。
    *   将 `PROD_HOST` 的值修改为**新生产服务器的 IP 地址**。
    *   重新启动主从复制和同步脚本，以确保新的生产数据能够继续被备份到 Cloud SQL。



=====================
##在中间服务器
====================
# 1. 配置：/etc/mysql/mysql.conf.d/replication.cnf
[mysqld]

服务器标识
server-id=2

Binlog配置
log_bin=/var/log/mysql/mysql-bin
binlog_format=ROW
binlog_row_image=FULL
expire_logs_days=3
max_binlog_size=500M

中继日志
relay_log=/var/log/mysql/relay-bin
relay_log_recovery=1
log_slave_updates=1

性能优化
innodb_buffer_pool_size=1G
innodb_log_file_size=256M
max_allowed_packet=1G

安全
binlog_checksum=CRC32
master_verify_checksum=1
slave_sql_verify_checksum=1

# 2. 重启 MySQL：（bash）sudo systemctl restart mysqld

# 3. 从生产服务器拉取备份（以下换成新的ip）
scp root@35.220.164.252:/tmp/bynewapi_initial.sql ./
scp root@35.220.164.252:/tmp/bynewapi_initial.sql.md5 ./
scp root@35.220.164.252:/tmp/master_status.txt ./

# 4. 验证备份完整性
md5sum -c bynewapi_initial.sql.md5

# 5. 导入数据到中间服务器
mysql -uroot -p'Middle@Server#2024Pass' < bynewapi_initial.sql

# 6. 配置主从复制（连接到生产服务器）
# 首先从master_status.txt获取binlog文件名和位置
BINLOG_FILE=$(grep "File:" master_status.txt | awk '{print $2}')
BINLOG_POS=$(grep "Position:" master_status.txt | awk '{print $2}')

# 7. 重新指向新生产服务器
（sql）
mysql -uroot -p'Middle@Server#2024Pass' << EOF
STOP SLAVE;

CHANGE MASTER TO
  MASTER_HOST='35.220.164.252',#换成新的ip
  MASTER_USER='repl_user',
  MASTER_PASSWORD='Repl@Pass#2024Secure',
  MASTER_LOG_FILE='$BINLOG_FILE',
  MASTER_LOG_POS=$BINLOG_POS;

START SLAVE;

SHOW SLAVE STATUS\G
EOF

=============
### **总结**
=============

这个恢复方案的核心是利用 `mysqldump` 将 Cloud SQL 上的数据完整地迁移回新的生产服务器。整个流程依赖于您在 `.env` 文件中配置的凭据。强烈建议您在非业务高峰期对这个恢复流程进行演练，以确保在真正发生灾难时能够从容应对。







═══════════════════════════════════════════════════════════════

              🎊 祝您使用愉快！ 🎊

   任何问题请查看文档或检查邮件告警

═══════════════════════════════════════════════════════════════






